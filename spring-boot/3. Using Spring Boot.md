## 3. 使用Spring Boot

本部分介绍使用Spring Boot的细节. 包含了这些主题: 构建系统, 自动配置和怎样运行你的应用. 我们也提到了一些使用SpringBoot的最佳实践. 尽管Spring Boot没有什么特别的(它只是又一个库), 这里还是有一些建议给你来使你的开发过程更加容易.

如果你还没有入门Spring Boot, 你应该读一下[入门指南](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#getting-started)后再开始这个部分.

#### 3.1. 构建系统

强烈推荐你选择一个支持[依赖管理](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-dependency-management)的并可以使用已经推送到Maven中央仓库的构建系统. 我们推荐你选择Maven或者Gradle. 可能还有其他的构建系统(例如Ant)也能和Spring Boot一起工作, 但是支持的不是特别好.

##### 3.1.1. 依赖管理

Spring Boot的每个发行版都提供了它所支持的依赖的版本. 实际上, 你并不需要在你的构建配置中提供任何一个依赖的版本, 因为Spring Boot帮你管理了. 当你升级Spring Boot的时候, 他们的版本也会随之升级.

> 如果你愿意, 你也可以指定一个特殊版本来覆盖Spring Boot的推荐.

精选列表包含可与Spring Boot一起使用的所有Spring模块和第三方库列表. 该列表作为可与[Maven](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-maven)和[Gradle](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-gradle)一起使用的标准物料清单`spring-boot-dependencies`提供。

每个发行的Spring Boot版本都关联了其基本的Spring Framework版本. 强烈建议您不要指定其版本.

###### 3.1.2. Maven

学习在Maven下使用Spring Boot, 参考以下Spring Boot的Maven插件文档:

- 文档([HTML](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/maven-plugin/reference/html/)或[PDF](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/maven-plugin/reference/pdf/spring-boot-maven-plugin-reference.pdf))
- [API](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/maven-plugin/api/)

###### 3.1.2. Gradle

学习在Gradle下使用Spring Boot, 参考以下Spring Boot的Gradle插件文档:

- 文档([HTML](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/gradle-plugin/reference/html/)或[PDF](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/gradle-plugin/reference/pdf/spring-boot-gradle-plugin-reference.pdf))
- [API](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/gradle-plugin/api/)

###### ~~3.1.4. Ant~~

###### 3.1.5. Starters(起步器)

Starter可以在你的应用程序中更方便描述依赖. 你可以一站式的得到Spring及相关技术而不必复制粘贴依赖和样例代码. 例如, 假设你想开始Spring和JPA来做数据库访问, 只需将`spring-boot-starter-data-jpa`依赖加入到你的项目.

Starters包含了许多启动项目并快速运行所需的依赖项, 并且支持受管理的依赖传递.

> 命名规则
>
> 所有官方的starters都遵循类似的命名规则, `spring-boot-starter-*`, 其中`*`代表特定类型的应用程序. 这种命名规则旨在帮你更快地查找starter. 需要集成了Maven的IDE都支持使用名称来搜索依赖. 例如, 在安装了适当的Eclipse或者STS插件后, 可以在POM编辑器中使用`ctrl-space`并输入"spring-boot-starter"来获取完整的列表.
>
> 正如"[Creating Your Own Starter](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-custom-starter)"中提到的一样, 第三方starters的命名不应该以`spring-boot`开头, 因为这是Spring Boot官方保留的. 相反, 第三方的starters应该以项目的名称开头. 例如, 一个第三方项目名叫`thirdpartyproject`就应该被命名为`thirdpartyproject-spring-boot-starter`.

Spring Boot在group为`org.springframework.boot`下提供了以下的starters:

TODO

除了应用的starters, 以下starter可以被应用于生产环境:

| 名称                           | 描述                                        |
| ------------------------------ | ------------------------------------------- |
| `spring-boot-starter-actuator` | 该starter可以在生产环境中监视和管理应用程序 |

最后, Spring Boot还包含了如下starters, 如果你需要排除或切换指定技术, 可以使用它们:

| 名称                                | 描述                                            |
| ----------------------------------- | ----------------------------------------------- |
| `spring-boot-starter-jetty`         | 使用Jetty作为servlet容器                        |
| `spring-boot-starter-log4j2`        | 使用Log4j4做日志记录                            |
| `spring-boot-starter-logging`       | 使用Logback做日志记录, 是默认的日志记录starter  |
| `spring-boot-starter-reactor-netty` | 使用Reactor Netty作为嵌入式的响应式的HTTP服务器 |
| `spring-boot-starter-tomcat`        | 使用Tomcat作为servlet容器, 是默认的.            |
| `spring-boot-starter-undertow`      | 使用Undertow作为servlet容器.                    |

#### 3.2. 你的代码结构

Spring Boot并不需要任何特殊的代码结构才能工作. 但是, 这里还是有一些有帮助的最佳实践.

##### 3.2.1. 使用"默认"包

当一个类没有`package`声明时, 它就是在"默认包"下. 通常不建议使用默认包, 这样会导致使用`@ComponentScan`, `@ConfigurationPropertiesScan`, `@Entity`, 或者`@SpringBootApplication`注解的Spring Boot应用出现特殊的问题. 因为每个jar中的每个类都会被扫描读取到.

> 我们推荐你遵循Java建议的包命名约定, 使用反向域名(例如: com.example.project).

##### 3.2.2. 主应用类的位置

我们通常推荐将你的主要应用类放在根包下且在其他类之上. 并使用`@SpringBootApplication`来标注你的主类. 这样会隐式的定义了需要扫描的包范围.

一个典型的包结构如下:

```
com
 +- example
     +- myapplication
         +- Application.java
         |
         +- customer
         |   +- Customer.java
         |   +- CustomerController.java
         |   +- CustomerService.java
         |   +- CustomerRepository.java
         |
         +- order
             +- Order.java
             +- OrderController.java
             +- OrderService.java
             +- OrderRepository.java
```

`Application.java`文件中定义了main方法, 并使用`@SpringBootApplication`标注:

```java
package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

#### 3.3. 配置类

SpringBoot偏向于使用基于Java文件的配置. 尽管也可以用XML, 但是我们通常建议你设置一个主要的`@Configuration`类. 通常, 首选定义了main方法的类来使用`@Configuration`.

> 在网上已经有很多使用XML配置的Spring示例. 如果可以, 请尝试使用等效的基于Java的配置. 搜索`Enable*`开头的注解即可开始.

##### 3.3.1. 导入额外的配置类

你不必将`@Configuration`放到一个单独的类中. 使用`@Import`注解可以导入其他的配置类. 或者, 你可以使用`@ComponentScan`来自动扫描所有Spring的组件, 包括标记了`@Configuration`的类.

##### 3.3.2. 导入XML配置

如果你坚持使用基于XML的配置, 我们还是推荐你从一个`@Configuration`类开始, 使用`@ImportResource`注解来加载XML配置文件.

#### 3.4. 自动配置

SpringBoot的自动配置会尝试根据你添加的依赖jar包来自动配置你的Spring应用. 例如, 如果`HSQLDB`在你的类路径上, 你不必手动配置任何数据库连接的bean, SpringBoot会自动配置一个内存数据库.

你需要通过向`@Configuration`类中添加`@EnableAutoConfiguration`或者`SpringBootApplication`注解来加入自动配置.

> 你应该只添加一个`@SpringBootApplication`或者`@EnableAutoConfiguration`注解. 我们通常建议你仅将一个或者其他的添加到主要的`@Configuration`类中.

##### 3.4.1. 取代自动配置

自动配置时非侵入性的. 任何时候, 你可以定义你自己的配置来代替自动配置的特定部分. 例如, 如果你添加了你自己的`DataSource`bean, 则默认的嵌入式数据库不再生效.

如果你需要查找当前被应用的自动配置及原因, 你可以使用`--debug`来启动你的应用. 这样可以启用调试日志并打印到控制台.

##### 3.4.2. 禁用特定的自动配置

如果你不想使用特定的自动配置, 你可以在`@SpringBootApplication`中添加属性来禁用, 示例如下:

```java
import org.springframework.boot.autoconfigure.*;
import org.springframework.boot.autoconfigure.jdbc.*;

@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})
public class MyApplication {
}
```

如果该类不在类路径中, 你可以使用`excludeName`属性来指定类的全限定名. 如果你更喜欢使用`@EnableAutoConfiguration`而不是`@SpringBootApplication`, 那么`exclude`和`excludeName`也是可用的. 最后, 你还可以使用配置`spring.autoconfigure.exclude`来配置要排除的自动配置列表.

> 你可以同时使用注释和配置类定义需要排除的内容.

> 尽管自动配置类是公开的, 但是我们不建议直接使用它.

#### 3.5. Spring 的组件和依赖注入(Beans and Dependency Injection)

你可以自由使用任何标准的Spring框架定义的beans及其注入的依赖. 简单起见, 我们通常将`@ComponentScan`(查找beans)和`@Autowired`(使用构造方法注入)组合使用.

如果你按照上面的建议来组织代码(将应用程序类放在根包中), 你可以添加`@ComponentScan`而不用添加任何参数, 你的应用的所有组件(`@Component`,`@Service`,`@Repository`,`Controller`等)都将自动注册为Spring的beans.

以下的示例显示一个使用构造方法注入来获取所需依赖的`@Service`bean

```java
package com.example.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class DatabaseAccountService implements AccountService {
  
    private final RiskAssessor riskAssessor;
  
    @Autowired
    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }
    // ...
}
```

如果一个bean只有一个构造方法, 你可以省略`@Autowired`注解, 如下所示:

```java
@Service
public class DatabaseAccountService implements AccountService {

    private final RiskAssessor riskAssessor;

    public DatabaseAccountService(RiskAssessor riskAssessor) {
        this.riskAssessor = riskAssessor;
    }
    // ...
}
```

> 请注意, 使用构造方法注入将字段`riskAssessor`标记为`final`, 它将不能被更改.

#### 3.6. 使用`@SpringBootApplication`注解

许多使用SpringBoot的开发人员喜欢使用自动配置, 组件扫描, 并且能够在应用程序类上定义额外的配置. 单个`@SpringBootApplication`注解即可启用这三个功能:

- `@EnableAutoConfiguration`: 启用[SpringBoot的自动配置](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-auto-configuration)
- `@ComponentScan`: 启用扫描默认包下的`@Component`(查看[最佳实践](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-structuring-your-code))
- `@Configuration`: 允许注册额外的bean到Spring容器中或者导入额外的配置类

```java
package com.example.myapplication;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

#### 3.7. 运行你的应用

将应用程序打包为jar文件并使用嵌入式的HTTP服务器的最大优势之一是, 你可以像运行其他应用一样来运行. 调试SpringBoot应用也很容易. 你不需要任何特殊的IDE插件或者扩展.

##### 3.7.1. 从IDE中运行

你可以在你的IDE中像运行一个简单的Java程序一样来运行SpringBoot应用. 第一步需要将你的项目导入到IDE中, 导入的步骤依赖于你的IDE和构建系统. 许多IDE都支持直接导入Maven项目. 例如, Eclipse用户可以在`File`菜单中选择`Import...`→`Existing Maven Projects`

如果你不能直接将你的项目导入到IDE中, 你可能需要使用Maven的插件来生成IDE的元数据. Maven包含了[Eclipse](https://maven.apache.org/plugins/maven-eclipse-plugin/)和[IDEA](https://maven.apache.org/plugins/maven-idea-plugin/)的插件. Gradle也提供了[各种插件](https://docs.gradle.org/current/userguide/userguide.html).

> 如果你意外的运行了一个web应用两次, 你会看到一个"Port already in use"错误. STS用户可以使用`Relaunch`按钮而不是`run`按钮来确保关闭任何现有的实例.

##### 3.7.2. 运行已打包的程序

如果你使用SpringBoot的Maven或者Gradle插件创建了一个可执行的jar, 你可以使用`java -jar`来运行, 如下:

```bash
java -jar target/myapplication-0.0.1-SNAPSHOT.jar
```

也可以在启用了远程调试支持的情况下运行打包的应用程序. 这样可以将调试器附加到打包的应用程序, 如以下示例所示:

```bash
java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n -jar target/myapplication-0.0.1-SNAPSHOT.jar
```

##### 3.7.3. 使用Maven插件

SpringBoot的Maven插件包含一个`run`的goal来让你快速编译和运行你的应用. 应用以exploded的形式(解压后的jar)运行, 就像在IDE中一样. 以下示例展示了使用Maven命令来运行一个SpringBoot应用:

```bash
mvn spring-boot:run
```

你可能需要使用`MAVEN_OPTS`环境变量, 如下所示:

```bash
export MAVEN_OPTS=-Xmx1024m
```

##### 3.7.4. 使用Gradle插件

SpringBoot的Gradle插件也包含了一个`bootRun`的task来让你以exploded的形式运行你的应用. 每当你使用`org.springframework.boot`和java插件时, `bootRun`task都会被添加使用:

```bash
gradle bootRun
```

你可能需要添加`JAVA_OPT`环境变量:

```bash
export JAVA_OPTS=-Xmx1024m
```

##### 3.7.5. 热部署

由于SpringBoot应用只是普通的Java应用程序, 因此JVM热部署可以立即使用. JVM热部署在一定程度上受到它可替换的字节码的限制. 更完整的方案, 可以使用[JRebel](https://www.jrebel.com/products/jrebel).

`spring-boot-devtools`模块还包含了对应用程序快速重启的支持. 详细信息请参考本章后面的"开发者工具"部分和热部署的"操作方式".

#### 3.8. 开发者工具